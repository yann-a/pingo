// Code generated by goyacc -o lambda/lambda.go -v lambda/lambda.output -p lambda lambda/lambda.y. DO NOT EDIT.

//line lambda/lambda.y:2

package lambda

import __yyfmt__ "fmt"

//line lambda/lambda.y:3

import (
	"bufio"
	"bytes"
	"log"
	"strconv"
	"unicode" // To tell apart letters from numbers
	"unicode/utf8"
)

//line lambda/lambda.y:16
type lambdaSymType struct {
	yys int
	ret lambda
	num lconst
	s   lvar
}

const FUN = 57346
const ARROW = 57347
const LPAREN = 57348
const RPAREN = 57349
const INT = 57350
const VAR = 57351

var lambdaToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"FUN",
	"ARROW",
	"LPAREN",
	"RPAREN",
	"INT",
	"VAR",
}
var lambdaStatenames = [...]string{}

const lambdaEofCode = 1
const lambdaErrCode = 2
const lambdaInitialStackSize = 16

//line lambda/lambda.y:53

// The parser expects the lexer to return 0 on EOF.  Give it a name
// for clarity.
const eof = 0

// The parser uses the type <prefix>Lex as a lexer. It must provide
// the methods Lex(*<prefix>SymType) int and Error(string).
type lambdaLex struct {
	ret    lambda
	reader *bufio.Reader
}

// The parser calls this method to get each new token. This
// implementation returns operators and NUM.
func (x *lambdaLex) Lex(yylval *lambdaSymType) int {
	for {
		c := x.next()
		switch c {
		case eof:
			return eof
		case '(':
			return LPAREN
		case ')':
			return RPAREN
		case ' ', '\t', '\n', '\r':
		default:
			if unicode.IsLetter(c) {
				return x.string(c, yylval)
			} else if unicode.IsNumber(c) {
				return x.num(c, yylval)
			}

			x.reader.UnreadRune()
			log.Printf("unrecognized character %q", c)
		}
	}
}

// Lex a number.
func (x *lambdaLex) num(c rune, yylval *lambdaSymType) int {
	add := func(b *bytes.Buffer, c rune) {
		if _, err := b.WriteRune(c); err != nil {
			log.Fatalf("WriteRune: %s", err)
		}
	}

	var b bytes.Buffer
	add(&b, c)

L:
	for {
		c = x.next()
		switch {
		case unicode.IsNumber(c):
			add(&b, c)
		default:
			if c != eof {
				x.reader.UnreadRune()
			}

			break L
		}
	}

	v, err := strconv.Atoi(b.String())
	if err != nil {
		log.Printf("bad number %q", b.String())
		return eof
	}

	yylval.num = lconst(v)

	return INT
}

// Lex a string.
func (x *lambdaLex) string(c rune, yylval *lambdaSymType) int {
	add := func(b *bytes.Buffer, c rune) {
		if _, err := b.WriteRune(c); err != nil {
			log.Fatalf("WriteRune: %s", err)
		}
	}

	var b bytes.Buffer
	add(&b, c)

L:
	for {
		c = x.next()
		switch {
		case unicode.IsLetter(c):
			add(&b, c)
		default:
			if c != eof {
				x.reader.UnreadRune()
			}

			break L
		}
	}

	yylval.s = lvar(b.String())

	return VAR
}

// Return the next rune for the lexer.
func (x *lambdaLex) next() rune {
	c, size, err := x.reader.ReadRune()

	if c == utf8.RuneError && size == 1 {
		log.Print("invalid utf8")
		return x.next()
	}

	if err != nil {
		return eof
	}

	return c
}

// The parser calls this method on a parse error.
func (x *lambdaLex) Error(s string) {
	log.Printf("parse error: %s", s)
}

//line yacctab:1
var lambdaExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
}

const lambdaPrivate = 57344

const lambdaLast = 20

var lambdaAct = [...]int{

	12, 4, 2, 8, 13, 6, 7, 8, 14, 6,
	7, 11, 10, 15, 5, 17, 16, 1, 9, 3,
}
var lambdaPact = [...]int{

	-3, -1000, -1000, 1, 3, -1000, -1000, -1000, -3, -1000,
	-1, 6, -1000, -3, -1, -1000, -1000, -1000,
}
var lambdaPgo = [...]int{

	0, 2, 14, 0, 19, 17,
}
var lambdaR1 = [...]int{

	0, 5, 1, 1, 3, 3, 4, 4, 2, 2,
	2,
}
var lambdaR2 = [...]int{

	0, 1, 1, 3, 2, 2, 1, 2, 1, 1,
	3,
}
var lambdaChk = [...]int{

	-1000, -5, -1, -4, 4, -2, 8, 9, 6, -2,
	9, -1, -3, 5, 9, 7, -1, -3,
}
var lambdaDef = [...]int{

	0, -2, 1, 2, 0, 6, 8, 9, 0, 7,
	0, 0, 3, 0, 0, 10, 4, 5,
}
var lambdaTok1 = [...]int{

	1,
}
var lambdaTok2 = [...]int{

	2, 3, 4, 5, 6, 7, 8, 9,
}
var lambdaTok3 = [...]int{
	0,
}

var lambdaErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	lambdaDebug        = 0
	lambdaErrorVerbose = false
)

type lambdaLexer interface {
	Lex(lval *lambdaSymType) int
	Error(s string)
}

type lambdaParser interface {
	Parse(lambdaLexer) int
	Lookahead() int
}

type lambdaParserImpl struct {
	lval  lambdaSymType
	stack [lambdaInitialStackSize]lambdaSymType
	char  int
}

func (p *lambdaParserImpl) Lookahead() int {
	return p.char
}

func lambdaNewParser() lambdaParser {
	return &lambdaParserImpl{}
}

const lambdaFlag = -1000

func lambdaTokname(c int) string {
	if c >= 1 && c-1 < len(lambdaToknames) {
		if lambdaToknames[c-1] != "" {
			return lambdaToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func lambdaStatname(s int) string {
	if s >= 0 && s < len(lambdaStatenames) {
		if lambdaStatenames[s] != "" {
			return lambdaStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func lambdaErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !lambdaErrorVerbose {
		return "syntax error"
	}

	for _, e := range lambdaErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + lambdaTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := lambdaPact[state]
	for tok := TOKSTART; tok-1 < len(lambdaToknames); tok++ {
		if n := base + tok; n >= 0 && n < lambdaLast && lambdaChk[lambdaAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if lambdaDef[state] == -2 {
		i := 0
		for lambdaExca[i] != -1 || lambdaExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; lambdaExca[i] >= 0; i += 2 {
			tok := lambdaExca[i]
			if tok < TOKSTART || lambdaExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if lambdaExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += lambdaTokname(tok)
	}
	return res
}

func lambdalex1(lex lambdaLexer, lval *lambdaSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = lambdaTok1[0]
		goto out
	}
	if char < len(lambdaTok1) {
		token = lambdaTok1[char]
		goto out
	}
	if char >= lambdaPrivate {
		if char < lambdaPrivate+len(lambdaTok2) {
			token = lambdaTok2[char-lambdaPrivate]
			goto out
		}
	}
	for i := 0; i < len(lambdaTok3); i += 2 {
		token = lambdaTok3[i+0]
		if token == char {
			token = lambdaTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = lambdaTok2[1] /* unknown char */
	}
	if lambdaDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", lambdaTokname(token), uint(char))
	}
	return char, token
}

func lambdaParse(lambdalex lambdaLexer) int {
	return lambdaNewParser().Parse(lambdalex)
}

func (lambdarcvr *lambdaParserImpl) Parse(lambdalex lambdaLexer) int {
	var lambdan int
	var lambdaVAL lambdaSymType
	var lambdaDollar []lambdaSymType
	_ = lambdaDollar // silence set and not used
	lambdaS := lambdarcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	lambdastate := 0
	lambdarcvr.char = -1
	lambdatoken := -1 // lambdarcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		lambdastate = -1
		lambdarcvr.char = -1
		lambdatoken = -1
	}()
	lambdap := -1
	goto lambdastack

ret0:
	return 0

ret1:
	return 1

lambdastack:
	/* put a state and value onto the stack */
	if lambdaDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", lambdaTokname(lambdatoken), lambdaStatname(lambdastate))
	}

	lambdap++
	if lambdap >= len(lambdaS) {
		nyys := make([]lambdaSymType, len(lambdaS)*2)
		copy(nyys, lambdaS)
		lambdaS = nyys
	}
	lambdaS[lambdap] = lambdaVAL
	lambdaS[lambdap].yys = lambdastate

lambdanewstate:
	lambdan = lambdaPact[lambdastate]
	if lambdan <= lambdaFlag {
		goto lambdadefault /* simple state */
	}
	if lambdarcvr.char < 0 {
		lambdarcvr.char, lambdatoken = lambdalex1(lambdalex, &lambdarcvr.lval)
	}
	lambdan += lambdatoken
	if lambdan < 0 || lambdan >= lambdaLast {
		goto lambdadefault
	}
	lambdan = lambdaAct[lambdan]
	if lambdaChk[lambdan] == lambdatoken { /* valid shift */
		lambdarcvr.char = -1
		lambdatoken = -1
		lambdaVAL = lambdarcvr.lval
		lambdastate = lambdan
		if Errflag > 0 {
			Errflag--
		}
		goto lambdastack
	}

lambdadefault:
	/* default state action */
	lambdan = lambdaDef[lambdastate]
	if lambdan == -2 {
		if lambdarcvr.char < 0 {
			lambdarcvr.char, lambdatoken = lambdalex1(lambdalex, &lambdarcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if lambdaExca[xi+0] == -1 && lambdaExca[xi+1] == lambdastate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			lambdan = lambdaExca[xi+0]
			if lambdan < 0 || lambdan == lambdatoken {
				break
			}
		}
		lambdan = lambdaExca[xi+1]
		if lambdan < 0 {
			goto ret0
		}
	}
	if lambdan == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			lambdalex.Error(lambdaErrorMessage(lambdastate, lambdatoken))
			Nerrs++
			if lambdaDebug >= 1 {
				__yyfmt__.Printf("%s", lambdaStatname(lambdastate))
				__yyfmt__.Printf(" saw %s\n", lambdaTokname(lambdatoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for lambdap >= 0 {
				lambdan = lambdaPact[lambdaS[lambdap].yys] + lambdaErrCode
				if lambdan >= 0 && lambdan < lambdaLast {
					lambdastate = lambdaAct[lambdan] /* simulate a shift of "error" */
					if lambdaChk[lambdastate] == lambdaErrCode {
						goto lambdastack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if lambdaDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", lambdaS[lambdap].yys)
				}
				lambdap--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if lambdaDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", lambdaTokname(lambdatoken))
			}
			if lambdatoken == lambdaEofCode {
				goto ret1
			}
			lambdarcvr.char = -1
			lambdatoken = -1
			goto lambdanewstate /* try again in the same state */
		}
	}

	/* reduction by production lambdan */
	if lambdaDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", lambdan, lambdaStatname(lambdastate))
	}

	lambdant := lambdan
	lambdapt := lambdap
	_ = lambdapt // guard against "declared and not used"

	lambdap -= lambdaR2[lambdan]
	// lambdap is now the index of $0. Perform the default action. Iff the
	// reduced production is ε, $1 is possibly out of range.
	if lambdap+1 >= len(lambdaS) {
		nyys := make([]lambdaSymType, len(lambdaS)*2)
		copy(nyys, lambdaS)
		lambdaS = nyys
	}
	lambdaVAL = lambdaS[lambdap+1]

	/* consult goto table to find next state */
	lambdan = lambdaR1[lambdan]
	lambdag := lambdaPgo[lambdan]
	lambdaj := lambdag + lambdaS[lambdap].yys + 1

	if lambdaj >= lambdaLast {
		lambdastate = lambdaAct[lambdag]
	} else {
		lambdastate = lambdaAct[lambdaj]
		if lambdaChk[lambdastate] != -lambdan {
			lambdastate = lambdaAct[lambdag]
		}
	}
	// dummy call; replaced with literal code
	switch lambdant {

	case 1:
		lambdaDollar = lambdaS[lambdapt-1 : lambdapt+1]
//line lambda/lambda.y:32
		{
			lambdalex.(*lambdaLex).ret = lambdaDollar[1].ret
		}
	case 2:
		lambdaDollar = lambdaS[lambdapt-1 : lambdapt+1]
//line lambda/lambda.y:35
		{
			lambdaVAL.ret = lambdaDollar[1].ret
		}
	case 3:
		lambdaDollar = lambdaS[lambdapt-3 : lambdapt+1]
//line lambda/lambda.y:36
		{
			lambdaVAL.ret = lfun{lambdaDollar[2].s, lambdaDollar[3].ret}
		}
	case 4:
		lambdaDollar = lambdaS[lambdapt-2 : lambdapt+1]
//line lambda/lambda.y:39
		{
			lambdaVAL.ret = lambdaDollar[2].ret
		}
	case 5:
		lambdaDollar = lambdaS[lambdapt-2 : lambdapt+1]
//line lambda/lambda.y:40
		{
			lambdaVAL.ret = lfun{lambdaDollar[1].s, lambdaDollar[2].ret}
		}
	case 6:
		lambdaDollar = lambdaS[lambdapt-1 : lambdapt+1]
//line lambda/lambda.y:43
		{
			lambdaVAL.ret = lambdaDollar[1].ret
		}
	case 7:
		lambdaDollar = lambdaS[lambdapt-2 : lambdapt+1]
//line lambda/lambda.y:44
		{
			lambdaVAL.ret = lapp{lambdaDollar[1].ret, lambdaDollar[2].ret}
		}
	case 8:
		lambdaDollar = lambdaS[lambdapt-1 : lambdapt+1]
//line lambda/lambda.y:47
		{
			lambdaVAL.ret = lambdaDollar[1].num
		}
	case 9:
		lambdaDollar = lambdaS[lambdapt-1 : lambdapt+1]
//line lambda/lambda.y:48
		{
			lambdaVAL.ret = lambdaDollar[1].s
		}
	case 10:
		lambdaDollar = lambdaS[lambdapt-3 : lambdapt+1]
//line lambda/lambda.y:49
		{
			lambdaVAL.ret = lambdaDollar[2].ret
		}
	}
	goto lambdastack /* stack new state and value */
}
